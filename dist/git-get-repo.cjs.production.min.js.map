{"version":3,"file":"git-get-repo.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["const downloadUrl = require('download');\nconst gitClone = require('git-clone');\nconst rm = require('rimraf').sync;\n\n/**\n * Download `repo` to `dest` and callback `fn(err)`.\n *\n * @param {String} repo\n * @param {String} dest\n * @param {Object} opts\n * @param {Function} fn\n */\n\nfunction download(repo: any, dest: string, opts: any, fn: Function) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n  opts = opts || {};\n  const clone = opts.clone || false;\n  delete opts.clone;\n\n  repo = normalize(repo);\n  const url = repo.url || getURL(repo, clone);\n\n  if (clone) {\n    const cloneOptions = {\n      checkout: repo.checkout,\n      shallow: repo.checkout === 'master',\n      ...opts,\n    };\n    gitClone(url, dest, cloneOptions, (err) => {\n      if (err === undefined) {\n        rm(dest + '/.git');\n        fn();\n      } else {\n        fn(err);\n      }\n    });\n  } else {\n    const downloadOptions = {\n      extract: true,\n      strip: 1,\n      mode: '666',\n      ...opts,\n      headers: {\n        accept: 'application/zip',\n        ...(opts.headers || {}),\n      },\n    };\n    downloadUrl(url, dest, downloadOptions)\n      .then(() => {\n        fn();\n      })\n      .catch((err) => {\n        fn(err);\n      });\n  }\n}\n\n/**\n * Normalize a repo string.\n *\n * @param {String} repo\n * @return {Object}\n */\n\nfunction normalize(repo: string) {\n  let regex: any = /^(?:(direct):([^#]+)(?:#(.+))?)$/;\n  let match: any[] = regex.exec(repo);\n  if (match) {\n    const url = match[2];\n    const directCheckout = match[3] || 'master';\n    return {\n      type: 'direct',\n      url: url,\n      checkout: directCheckout,\n    };\n  } else {\n    regex =\n      /^(?:(github|gitlab|bitbucket|gitee):)?(?:(.+):)?([^/]+)\\/([^#]+)(?:#(.+))?$/;\n    match = regex.exec(repo);\n\n    const type: string = match[1] || getType(repo);\n    let origin: any = match[2] || null;\n    const owner: string = match[3];\n    const name: string = match[4];\n    const checkout: string = match[5] || 'master';\n\n    const ori = {\n      github: 'github.com',\n      gitlab: 'gitlab.com',\n      bitbucket: 'bitbucket.org',\n      gitee: 'gitee.com',\n    };\n\n    origin = origin == null ? ori[type] : origin;\n\n    return {\n      type: type,\n      origin: origin,\n      owner: owner,\n      name: name,\n      checkout: checkout,\n    };\n  }\n}\n\nfunction getType(repo: string) {\n  const gits = ['github', 'gitlab', 'bitbucket', 'gitee'];\n  let type = gits[0];\n  gits.forEach((v) => {\n    if (repo.includes(v)) {\n      type = v;\n    }\n  });\n  return type;\n}\n\n/**\n * Adds protocol to url in none specified\n *\n * @param {String} url\n * @return {String}\n */\n\nfunction addProtocol(origin: string, clone: boolean): string {\n  if (!/^(f|ht)tps?:\\/\\//i.test(origin)) {\n    origin = clone ? `git@${origin}` : `https://${origin}`;\n  }\n\n  return origin;\n}\n\n/**\n * Return a zip or git url for a given `repo`.\n *\n * @param {Object} repo\n * @return {String}\n */\n\nfunction getURL(repo: any, clone: boolean): string {\n  // Get origin with protocol and add trailing slash or colon (for ssh)\n  let origin = addProtocol(repo.origin, clone);\n  origin = /^git@/i.test(origin) ? `${origin}:` : `${origin}/`;\n\n  const href = `${origin}${repo.owner}/${repo.name}`;\n  const uri: any = {\n    github: `${href}/archive/${repo.checkout}.zip`,\n    gitlab: `${href}/repository/archive.zip?ref=${repo.checkout}`,\n    bitbucket: `${href}/get/${repo.checkout}.zip`,\n    gitee: `${href}/repository/archive/${repo.checkout}.zip`,\n  };\n\n  const url = clone ? `${href}.git` : uri[repo.type];\n\n  return  url;\n}\n\nmodule.exports = download;\n"],"names":["downloadUrl","require","gitClone","rm","sync","module","exports","repo","dest","opts","fn","clone","url","regex","match","exec","type","checkout","gits","forEach","v","includes","getType","origin","github","gitlab","bitbucket","gitee","owner","name","normalize","test","addProtocol","href","getURL","cloneOptions","shallow","err","undefined","downloadOptions","extract","strip","mode","headers","accept","then"],"mappings":"4NAAA,IAAMA,EAAcC,QAAQ,YACtBC,EAAWD,QAAQ,aACnBE,EAAKF,QAAQ,UAAUG,KA6J7BC,OAAOC,QAlJP,SAAkBC,EAAWC,EAAcC,EAAWC,GAChC,mBAATD,IACTC,EAAKD,EACLA,EAAO,UAGHE,GADNF,EAAOA,GAAQ,IACIE,QAAS,SACrBF,EAAKE,UAGNC,GADNL,EA6CF,SAAmBA,OACbM,EAAa,mCACbC,EAAeD,EAAME,KAAKR,MAC1BO,QAGK,CACLE,KAAM,SACNJ,IAJUE,EAAM,GAKhBG,SAJqBH,EAAM,IAAM,cAW7BE,GAFNF,GAFAD,EACE,+EACYE,KAAKR,IAEQ,IAyB/B,SAAiBA,OACTW,EAAO,CAAC,SAAU,SAAU,YAAa,SAC3CF,EAAOE,EAAK,UAChBA,EAAKC,SAAQ,SAACC,GACRb,EAAKc,SAASD,KAChBJ,EAAOI,MAGJJ,EAjC4BM,CAAQf,GACrCgB,EAAcT,EAAM,IAAM,WAcvB,CACLE,KAAMA,EACNO,OAJFA,EAAmB,MAAVA,EAPG,CACVC,OAAQ,aACRC,OAAQ,aACRC,UAAW,gBACXC,MAAO,aAGqBX,GAAQO,EAKpCK,MAhBoBd,EAAM,GAiB1Be,KAhBmBf,EAAM,GAiBzBG,SAhBuBH,EAAM,IAAM,UAjEhCgB,CAAUvB,IACAK,KAsHnB,SAAgBL,EAAWI,OAErBY,EAjBN,SAAqBA,EAAgBZ,SAC9B,oBAAoBoB,KAAKR,KAC5BA,EAASZ,SAAeY,aAAsBA,GAGzCA,EAYMS,CAAYzB,EAAKgB,OAAQZ,GAGhCsB,GAFNV,EAAS,SAASQ,KAAKR,GAAaA,MAAeA,OAE1BhB,EAAKqB,UAASrB,EAAKsB,YAQhClB,EAAWsB,SAPN,CACfT,OAAWS,cAAgB1B,EAAKU,gBAChCQ,OAAWQ,iCAAmC1B,EAAKU,SACnDS,UAAcO,UAAY1B,EAAKU,gBAC/BU,MAAUM,yBAA2B1B,EAAKU,iBAGJV,EAAKS,MAnIrBkB,CAAO3B,EAAMI,MAEjCA,EAAO,KACHwB,KACJlB,SAAUV,EAAKU,SACfmB,QAA2B,WAAlB7B,EAAKU,UACXR,GAELP,EAASU,EAAKJ,EAAM2B,GAAc,SAACE,QACrBC,IAARD,GACFlC,EAAGK,EAAO,SACVE,KAEAA,EAAG2B,UAGF,KACCE,KACJC,SAAS,EACTC,MAAO,EACPC,KAAM,OACHjC,GACHkC,WACEC,OAAQ,mBACJnC,EAAKkC,SAAW,MAGxB3C,EAAYY,EAAKJ,EAAM+B,GACpBM,MAAK,WACJnC,cAEK,SAAC2B,GACN3B,EAAG2B"}